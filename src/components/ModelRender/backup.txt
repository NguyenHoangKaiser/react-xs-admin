/* eslint-disable react/no-unknown-property */
import React, {
  useRef,
  useContext,
  Suspense,
  useCallback,
  useState,
  useMemo,
  useEffect,
} from 'react';
import { Html, OrbitControls } from '@react-three/drei';
import type { ThreeEvent } from '@react-three/fiber';
import { extend, useFrame, useThree, Canvas } from '@react-three/fiber';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader';
import type { Texture, WebGLRenderTarget } from 'three';
import { Vector2 } from 'three';
import './style.less';
import Loader from './Loader';

extend({ EffectComposer, RenderPass, OutlinePass, ShaderPass });

interface IContext {
  setHovered: React.Dispatch<React.SetStateAction<any[]>>;
  setTooltip: React.Dispatch<React.SetStateAction<any[]>>;
  setActivePanel: React.Dispatch<React.SetStateAction<any[]>>;
}

const context = React.createContext<IContext>({
  setHovered: () => {},
  setTooltip: () => {},
  setActivePanel: () => {},
});

interface ModelRenderProps {
  children: React.ReactNode;
  tooltip: any[];
  setTooltip: React.Dispatch<React.SetStateAction<any[]>>;
  disableDraggable: boolean;
  setActivePanel: React.Dispatch<React.SetStateAction<any[]>>;
  color: string;
  onClickOutside: () => void;
}

function ModelRender({
  children,
  tooltip,
  setTooltip,
  disableDraggable,
  setActivePanel,
  color,
  onClickOutside,
}: ModelRenderProps) {
  const [hovered, setHovered] = useState<any[]>([]);
  const active = tooltip ? tooltip.map((el) => el.ref) : [];
  const outline = useMemo(() => {
    const arr: any[] = [];
    hovered.forEach((el) => {
      if (!active.includes(el)) {
        arr.push(el);
      }
    });
    return arr;
  }, [hovered, active]);
  const onPointerMissed = useCallback((e: MouseEvent) => {
    e.stopPropagation();
    setHovered([]);
    setTooltip([]);
    onClickOutside && onClickOutside();
  }, []);

  return (
    <div className="custom-canvas">
      <Canvas
        // pixelRatio={window.devicePixelRatio}
        frameloop={disableDraggable ? 'demand' : 'always'}
        camera={{ position: [0, 15, 5], far: 10000 }}
        onPointerMissed={onPointerMissed}
      >
        <context.Provider value={{ setHovered, setTooltip, setActivePanel }}>
          <Suspense fallback={<Loader />}>
            <color attach="background" args={[color ?? '#232743']} />
            <ambientLight color={'#fff'} intensity={1} />
            <spotLight position={[-15, 10, 5]} />
            <spotLight position={[5, 10, -10]} />
            <OrbitControls makeDefault enableDamping={false} />
            <Outline outline={outline} active={active} />
            {children}
            {/* <axesHelper args={[15]} /> */}
            {/* <gridHelper args={[40, 40]} /> */}
            {/* <OrbitControls
              enablePan={false}
              minPolarAngle={Math.PI / 8}
              makeDefault
              enableDamping={false}
              maxPolarAngle={Math.PI / 2 - 0.1}
            /> */}
          </Suspense>
        </context.Provider>
      </Canvas>
    </div>
  );
}

export default ModelRender;

export function useHover(
  id: string,
  onClickCallback: (e: ThreeEvent<MouseEvent>) => void,
  onlyOnClick = false,
) {
  const ref = useRef<THREE.Mesh>(null!);
  const { setHovered, setTooltip, setActivePanel } = useContext(context);
  const onPointerOver = useCallback((e: MouseEvent) => {
    e.stopPropagation();
    setHovered((state) => [...state, ref.current]);
  }, []);
  const onPointerOut = useCallback(
    () => setHovered((state) => state.filter((mesh) => mesh !== ref.current)),
    [],
  );
  const onClick = useCallback((e: ThreeEvent<MouseEvent>) => {
    e.stopPropagation();
    if (onlyOnClick) {
      onClickCallback(e);
      return;
    }
    setTooltip((state) => {
      if (state.find((el) => el.uuid === ref.current.uuid)) {
        return state.filter((el) => el.uuid !== ref.current.uuid);
      }
      return [...state, { position: e.point, id: id, uuid: ref.current.uuid, ref: ref.current }];
    });
    setActivePanel([id]);
    onClickCallback && onClickCallback(e);
  }, []);
  return { ref, onPointerOver, onPointerOut, onClick };
}

const Outline = ({ outline, active }) => {
  const { gl, scene, camera, size } = useThree();
  const composer = useRef<EffectComposer<WebGLRenderTarget<Texture>>>(null!);
  const aspect = useMemo(() => new Vector2(size.width, size.height), [size]);
  useEffect(() => composer.current.setSize(size.width, size.height), [size]);
  useFrame(() => composer.current.render(), 1);
  return (
    <effectComposer ref={composer} args={[gl]}>
      <renderPass attachArray="passes" args={[scene, camera]} />
      <outlinePass
        attachArray="passes"
        args={[aspect, scene, camera]}
        selectedObjects={outline}
        visibleEdgeColor="white"
        edgeStrength={50}
        edgeThickness={1}
      />
      <outlinePass
        attachArray="passes"
        args={[aspect, scene, camera]}
        selectedObjects={active}
        visibleEdgeColor="red"
        edgeStrength={50}
        edgeThickness={1}
      />
      <shaderPass
        attachArray="passes"
        args={[FXAAShader]}
        uniforms-resolution-value={[1 / size.width, 1 / size.height]}
      />
    </effectComposer>
  );
};

export const Annotation = ({ tooltip, model }) => {
  if (model === 'class') {
    return (
      <>
        {tooltip &&
          tooltip.map((el) => (
            <Html
              key={`tooltip-${el.id}-${el.position}`}
              position={el.position}
              zIndexRange={[1, 0]}
            >
              <div className="iconAnnotation">
                <p>{el.name}</p>
              </div>
            </Html>
          ))}
      </>
    );
  }

  if (model === 'chiller') {
    return (
      <>
        {tooltip &&
          tooltip.map((el) => (
            <Html
              key={`tooltip-${el.id}-${el.position}`}
              position={el.position}
              zIndexRange={[1, 0]}
            >
              <div className="annotation">
                <p>{el.name}</p>
                <p>{`Temp: ${el.data[0].temp} Â°C`} </p>
              </div>
            </Html>
          ))}
      </>
    );
  }
  if (model === 'parking') {
    return (
      <>
        {tooltip.map((el) => (
          <Html key={`tooltip-${el.id}-${el.position}`} position={el.position} zIndexRange={[1, 0]}>
            <div className="iconAnnotation">
              <p>{el.name}</p>
            </div>
          </Html>
        ))}
      </>
    );
  }
  if (model === 'building') {
    return (
      <>
        {tooltip.map((el) => (
          <Html key={`tooltip-${el.id}-${el.position}`} position={el.position} zIndexRange={[1, 0]}>
            <div className="iconAnnotation">
              <p>{`${el.position.x}, ${el.position.y}, ${el.position.z}`}</p>
            </div>
          </Html>
        ))}
      </>
    );
  }
  return null;
};

export const RenderTitle = ({ data, onClick, highlight = [] }) => {
  return (
    <>
      {data &&
        data.map((el) => (
          <Html key={`tooltip-${el.id}`} position={el.pos.position} zIndexRange={[1, 0]}>
            {el.status === 1 ? (
              <div
                onClick={() => onClick(el)}
                style={
                  highlight.includes(el.id)
                    ? {
                        opacity: 1,
                        border: '1px solid #fff',
                      }
                    : {}
                }
                className="titleAnnotation"
              >
                <p>{el.name}</p>
              </div>
            ) : (
              <div className="titleDisabled">
                <p>{el.name}</p>
              </div>
            )}
          </Html>
        ))}
    </>
  );
};
